# Workflow name
name: Build, Test, Dockerize and Deploy .NET App

# Trigger:
on:
  push:
    branches: [ master ]
  pull_request: 
    branches: [ master ]

jobs:
  # Job 1: Build the app
  build:
    runs-on: ubuntu-latest
    
    steps:
      # Download code from repo
      - name: Checkout code
        uses: actions/checkout@v4
        
      # Installs .NET 9 SDK
      - name: Setup .NET
        uses: actions/setup-dotnet@v4
        with: 
          dotnet-version: 9.0.x

      - name: NuGet packages caching
        uses: actions/cache@v4
        with:
            path: ~/.nuget/packages
            # A chave de cache muda se o arquivo de dependências for alterado
            key: ${{ runner.os }}-nuget-${{ hashFiles('**/*.csproj') }}
            restore-keys: |
              ${{ runner.os }}-nuget-
              
      # Restore dependencies
      - name: Restore dependencies
        run: dotnet restore KnowledgeQuiz.Api.sln
        
      # Build the project in release mode
      - name: Build
        run: dotnet build KnowledgeQuiz.Api.sln --configuration Release --no-restore
        
      # Publish webApi project
      - name: Publish app
        run: dotnet publish src/KnowledgeQuiz.Api.WebApi/KnowledgeQuiz.Api.WebApi.csproj -c Release -o out
  
  # Job 2: Test the app and initialize services
  test:
    runs-on: ubuntu-latest
    needs: build
    services:
      postgres:
        image: postgres:15
        env:
          POSTGRES_USER: quizuser
          POSTGRES_PASSWORD: quizpass
          POSTGRES_DB: quizdb
        ports:
          - 5432:5432
        options: --health-cmd="pg_isready" --health-interval=10s --health-timeout=5s --health-retries=5
      
      elasticsearch:
        image: docker.elastic.co/elasticsearch/elasticsearch:8.13.0
        env:
          discovery.type: single-node
          xpack.security.enabled: false
        ports:
          - 9200:9200
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup .NET
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: 9.0.x
          
      - name: Set test connection string
        run: echo "ConnectionStrings__Default=Host=localhost;Port=5432;Database=quizdb;Username=quizuser;Password=quizpass" >> $GITHUB_ENV      
      
      # Run tests
      - name: Run tests
        run: dotnet test KnowledgeQuiz.Api.sln --no-build --configuration Release --verbosity normal --logger trx --collect:"XPlat Code Coverage"
        continue-on-error: true # Remove this when we actually have tests
        
      # Combine all of the reports into a single one
      - name: Combine Coverage Reports
        uses: danielpalme/ReportGenerator-GitHub-Action@5.2.4
        with:
          reports: "**/*.cobertura.xml"
          targetdir: "${{ github.workspace }}"
          reporttypes: "Cobertura" # The output formats and scope (separated by semicolon) Values: Badges, Clover, Cobertura, CsvSummary, Html, Html_Dark, Html_Light, Html_BlueRed, HtmlChart, HtmlInline, HtmlInline_AzurePipelines, HtmlInline_AzurePipelines_Dark, HtmlInline_AzurePipelines_Light, HtmlSummary, JsonSummary, Latex, LatexSummary, lcov, MarkdownSummary, MarkdownSummaryGithub, MarkdownDeltaSummary, MHtml, PngChart, SonarQube, TeamCitySummary, TextSummary, TextDeltaSummary, Xml, XmlSummary
          verbosity: "Info"
          title: "Knowledge Quiz API Code Coverage"
          tag: "${{ github.run_number }}_${{ github.run_id }}"
          toolpath: "reportgeneratortool"
          
      # Upload report to build artifact
      - name: Upload Combined Coverage XML
        uses: actions/upload-artifact@v4
        with:
          name: coverage
          path: ${{ github.workspace }}/Cobertura.xml
          retention-days: 5
      
      - name: Publish Code Coverage Report
        uses: irongut/CodeCoverageSummary@v1.3.0
        with:
          filename: "Cobertura.xml"
          badge: true
          fail_below_min: false # when we have a nice quantity we can change to true
          format: markdown
          hide_branch_rate: false
          hide_complexity: false
          indicators: true
          output: both
          thresholds: '10 30'
          
      - name: Add Coverage PR Comment
        uses: marocchino/sticky-pull-request-comment@v2
        if: github.event_name == 'pull_request'
        with:
          recreate: true
          path: code-coverage-results.md

      - name: Upload Test Result Files
        uses: actions/upload-artifact@v4
        with:
          name: test-results
          path: ${{ github.workspace }}/**/TestResults/**/*
          retention-days: 5

      - name: Publish Test Results
        uses: EnricoMi/publish-unit-test-result-action@v2.16.1
        if: always()
        with:
          trx_files: "${{ github.workspace }}/**/*.trx"


  # Deploy the app
  deploy:
    runs-on: ubuntu-latest
    needs: test
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        
      # Build docker image
      - name: Build docker image
        run: docker build -t abelpinheiro/knowledgequiz-api -f Dockerfile .
      
      # 8. (optional) Push to docker hub or another registry
      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Push image
        run: docker push abelpinheiro/knowledgequiz-api

#
#  # Job 3: Deploy to Docker Hub
#  deploy:
#    runs-on: ubuntu-latest
#    needs: test  # Só roda depois que os testes passarem
#    steps:
#      - name: Login to Docker Hub
#        uses: docker/login-action@v3
#        with:
#          username: ${{ secrets.DOCKERHUB_USERNAME }}
#          password: ${{ secrets.DOCKERHUB_TOKEN }}
#      - name: Build Docker image
#        run: docker build -t yourusername/knowledgequiz-api:latest .
#      - name: Push Docker image
#        run: docker push yourusername/knowledgequiz-api:latest
  
#  3. Sugestões e Melhorias
#Melhoria na organização do Dockerfile: Para maior controle e melhores práticas de Docker, pode ser interessante usar multi-stage builds para reduzir o tamanho da imagem e otimizar o processo de criação. Você pode fazer isso separando as etapas de build e runtime em diferentes estágios no Dockerfile.
#
#Testes de unidade no pipeline: Quando você começar a escrever os testes, sugiro garantir que os testes de unidade estejam integrados ao CI/CD. Isso impede que código com falhas passe para a produção.
#
#Ambiente de deploy: Para completar o deploy, você pode adicionar uma etapa de deploy automático para um ambiente de staging ou produção. Isso depende da sua infraestrutura (se você usa algo como AWS, Azure, ou Google Cloud, por exemplo). Caso contrário, o fluxo de build e push da imagem para o Docker Hub já pode ser suficiente para o momento.
#
#GitHub Secrets: Certifique-se de que você está armazenando suas credenciais de Docker Hub ou qualquer outro serviço em Secrets no GitHub, como você já está fazendo. Isso é uma boa prática de segurança.